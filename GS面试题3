80、vue中组件之间的通信方式？
回答范例：
1.	组件通信方式大体有以下8种：
•	props
•	$emit/$on
•	$children/$parent
•	$attrs/$listeners
•	ref
•	$root
•	eventbus
•	vuex
2.	根据组件之间关系讨论组件通信最为清晰有效
•	父子组件
o	props
o	$emit/$on
o	$parent / $children
o	ref
o	$attrs / $listeners
•	兄弟组件
o	$parent
o	eventbus
o	vuex
•	跨层级关系
o	provide/inject
o	$root
o	eventbus
o	vuex
81、什么是vue-loader？
Vue-loader 是 Webpack 的加载器模块，它使我们可以用 .vue 文件格式编写单文件组件。单文件组件文件有三个部分，即模板、脚本和样式。 vue-loader 模块允许 webpack 使用单独的加载器模块（例如 SASS 或 SCSS 加载器）提取和处理每个部分。该设置使我们可以使用 .vue 文件无缝编写程序。
vue-loader 模块还允许把静态资源视为模块依赖性，并允许使用 webpack 加载器进行处理。而且还允许在开发过程中进行热重装。
82、什么是 mixin？
Mixins 使我们能够为 Vue 组件编写可插拔和可重用的功能。如果你希望在多个组件之间重用一组组件选项，例如生命周期 hook、方法等，则可以将其编写为 mixin，并在组件中简单地引用它。然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优先于组件自己的 hook 。
83、在开发过程中，如果你的 Vue 程序和后端 API 服务器未在同一主机上运行，该如何代理 API 请求。假设使用 Vue-CLI 3 进行设置？
假设我们有一个运行在 localhost:4040 上的 Node.js 后端服务器。为了确保代理并可以从组件中访问它，可以配置 vue.config.js 文件并包含 devServer 部分，如下所示：
在 vue.config.js 文件中：
module.exports: {
    devServer: {
        proxy: {
            '/api': { 
                target: ‘http://localhost:4040/api’, 
                changeOrigin: true 
            }
        }
    }
}
84、prop 如何指定其类型要求？
通过实现 prop 验证选项，可以为单个 prop 指定类型要求。这对生产没有影响，但是会在开发阶段发出警告，从而帮助开发人员识别传入数据和 prop 的特定类型要求的潜在问题。
配置三个 prop 的例子：
props: {
    accountNumber: {
        type: Number,
        required: true
    },
    name: {
        type: String,
        required: true
   },
   favoriteColors: Array
}
85、什么是异步组件？
当大型程序使用大量组件时，从服务器上同时加载所有组件可能是没有意义的。在这种情况下，Vue 允许我们在需要时定义从服务器异步加载的组件。在声明或注册组件时，Vue 接受提供 Promise 的工厂函数。然后可以在调用该组件时对其进行“解析”。
通过仅加载基本组件并把异步组件的加载推迟到未来的调用时间，可以节省带宽和程序加载时间。
这是一个异步组件的简单示例。
new Vue({
    components: {
        ‘tweet-box’: () => import(‘./components/async/TweetBox’)
    }
}); 
当以这种方式使用时，Webpack 的代码拆分将用于提供此功能。
86、Vuex刷新时数据会消失，那如何解决？为什么还要使用Vuex
原因：
因为store里的数据是保存在运行内存中的,当页面刷新时，页面会重新加载vue实例，store里面的数据就会被重新赋值初始化
一：.利用vuex-persistedstate插件
插件的原理其实也是结合了存储方式,只是统一的配置就不需要手动每次都写存储方法

二：解决思路：
将state的数据保存在localstorage、sessionstorage或cookie中，这样即可保证页面刷新数据不丢失且易于读取。
1.	localStorage: localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。
2.	sessionStorage:sessionStorage的生命周期是在仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。
3.	cookie:cookie生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 存放数据大小为4K左右,有个数限制（各浏览器不同），一般不能超过20个。缺点是不能储存大数据且不易读取。
由于vue是单页面应用，操作都是在一个页面跳转路由，因此sessionStorage较为合适,原因如下：
1.	sessionStorage可以保证打开页面时sessionStorage的数据为空；
2.	每次打开页面localStorage存储着上一次打开页面的数据，因此需要清空之前的数据。
vuex的数据在每次页面刷新时丢失，是否可以在页面刷新前再将数据存储到sessionstorage中呢，是可以的，beforeunload事件可以在页面刷新前触发，但是在每个页面中监听beforeunload事件感觉也不太合适，那么最好的监听该事件的地方就在app.vue中。
1.	在app.vue的created方法中读取sessionstorage中的数据存储在store中，此时用vuex.store的replaceState方法，替换store的根状态
2.	在beforeunload方法中将store.state存储到sessionstorage中。
vuex中state数据的修改必须通过mutation方法进行修改，因此mutation修改state的同时需要修改sessionstorage,问题倒是可以解决但是感觉很麻烦，state中有很多数据，很多mutation修改state就要很多次sessionstorage进行修改，既然如此直接用sessionstorage解决不就行了，为何还要用vuex多此一举呢？
　　vuex可以实现数据响应，而sessionstorage是不可以的，我们使用vuex 的主要目的是为了各个组件之间的传参，通过数据改变视图。而sessionstorage是做不到这一点的。

87、Vuex响应式原理
1、在vuex的state里面，每一个对象中的属性（key值），都会有一个Dep[1，2 ]观察者，当这个key变化时，dep就会去看它里面的数组包含了哪些地方用到了这个key值，然后更新他们。
State:{
Name:’bit’ => Dep[ 组件一，组件二 ] 组件一，二，用到了这个值
}
2、在mutations同步和actions异步中，如果异步操作不放在actions中，就会导致devtools浏览器插件中的记录state快照失效，
88、ES6经典面试题
1.箭头函数有哪些特性
1、箭头函数是匿名函数，不绑定自己的this,arguments,super,new.target
2、箭头函数会捕获其所在上下文的this值，作为自己的this值，在使用call/apply绑定时，相当于只是传入了参数，对this没有影响
3、箭头函数不绑定arguments，取而代之用rest参数…解决
4、箭头函数当方法使用的时候，没有定义this绑定
5、箭头函数不能作为构造函数，和 new 一起用就会抛出错误
6、箭头函数没有原型属性
7、不能简单返回对象字面量
2.实现数组过滤重复
  Let s = [...new Set(arr)]
3.使用json方式实现深拷贝
let arr2 = JSON.parse(JSON.stringify(arr1));
4.ES6模板字符串有哪些好处
 a. 在ES5拼接的时候，如果结构需要换行，必须使用转义符；在ES6中，使用模板字符串，直接使用html结构即可
b. 在ES5中，单引号和双引号必须注意嵌套问题，在ES6中，就不需要考虑；
c. 模板字符串中，可以写js语句
d. 方便简洁，不容易出错；
5.关于对象扩展的属性简写和属性名表达方式写法，请各举一个例子
1. 属性的简写：必须属性名和变量名相同
3. 属性表达式：[]里面可以是变量，字符串，数字，表达式
注意：如果对象的属性是数字，不可以使用点进行访问
属性名简写：
var title = 'offc';
var size = 10;
var obj = {
title,
size,
};
属性名表达式：
var title = 'offc';
obj[title] = '简书';

6.手写promise
var p = new Promise((resolve,reject)={
if(1){
resolve(‘成功’)
}
else{
reject(‘失败’);
}
})
p.then((res)=>{}).catch((err)=>{})
7.用class定义一个类
class Aniaml{
static Type = ‘动物’
constructor(newName){
this.name = newName
}
eat(){conosle.log(‘吃东西’)}
static sayHi(){
console.log(‘大家好’)
}
}

8.class实现继承
class Tigger extends Animal{
constructor(props){
super(props)
}
}
9.谈一下对async。。。。await的理解
async...await是基于promise的generator语法糖，它用来等待promise的执行结果，常规函数使用await没有效果；async修饰的函数内部return不会得到预期的结果，会得到一个promise对象；await等待的promise结果是resolve状态的内容，reject状态的内容需要使用try...catch获取，await关键字必须要出现在async修饰的函数中，否则报错。
10.ES6中的symbol类型有什么作用
ES6新增了Symbol数据类型，它用来生成一个独一无二的值，它Symbol数据常用来给对象属性赋值，让对象属性具备唯一性，不容易被覆盖。
11.class类中的super有哪些用法
Super在类中有两种用法，一个是super方法，一个是super对象；super方法只能出现在constructor方法中，super对象一般出现在子类覆盖父类的方法中。
12.静态和成员的区别
静态的变量或方法归类所有，全局独一份，成员的变量或方法归对象所有，每次实例化对象成员方法和成员变量就会得到一份拷贝；对于一些通用性的属性或方法，可以考虑设置为静态。

13.谈一体你多promise的理解
Promise用来解决异步回调问题，由于js是单线程的，很多异步操作都是依靠回调方法实现的，这种做法在逻辑比较复杂的回调嵌套中会相当复杂；也叫做回调地狱；promise用来将这种繁杂的做法简化，让程序更具备可读性，可维护性；promise内部有三种状态，pedding，fulfilled，rejected；pedding表示程序正在执行但未得到结果，即异步操作没有执行完毕，fulfilled表示程序执行完毕，且执行成功，rejected表示执行完毕但失败；这里的成功和失败都是逻辑意义上的；并非是要报错。其实，promise和回调函数一样，都是要解决数据的传递和消息发送问题，promise中的then一般对应成功后的数据处理，catch一般对应失败后的数据处理。Promise状态一旦确定，就不会再次发生改变
14.深拷贝的原理
Js的深拷贝发生在对象的赋值上，对象赋值的时候仅仅是一个引用赋值，也就是说两个不同变量名指向的是同一份内存空间；基本数据类型则不存在这样的行为；要完成对象的深拷贝需要使用递归遍历所有对象的属性进行赋值，也可以使用JSON.stringfy和JSON.parse操作。

15.set和map的区别
Set是一种类似数组的集合类型，它与数组不同的是，不允许存在重复数据；常用操作方法有：add,delete,has,clear等；遍历使用forEach；
Map是一种类似对象的集合类型，它与对象不同的是，key可以接受对象类型，常用的操作方法有：set,get,has,delete等；遍历使用forEach
16.node的特点是什么
1）它是一个Javascript运行环境
2）依赖于Chrome V8引擎进行代码解释
3）事件驱动
4）非阻塞I/O
5）轻量、可伸缩，适于实时数据交互应用
6）单进程，单线程

17.module.exports和exports的区别，请用代码示范
Exports和module.exports的区别：
1）exports相当于在js文件的首行写了let exports = module.exports;（但是实际情况不需要写，否则报错）
2）exports不可以直接赋值，如果直接赋值相当于与module.exports切断了联系，没有了导出功能；
3）如果exports和module.exports同时导出，exports就失去了导出的功能；
4）注意点：module.exports只使用一次即可，多个变量输出的时候，可以使用对象的形式
18.MIME类型有什么作用
MIME的全称是Multipurpose Internet Mail Extensions，即多用途互联网邮件扩展类型。这是HTTP协议中用来定义文档性质及格式的标准。服务器通过MIME告知响应内容类型，而浏览器则通过MIME类型来确定如何处理文档。
常见MIME类型：
application/octet-stream?未知的应用程序文件
application/json?json数据
text/plain未知的文本文件（纯文本文件），浏览器会认为这是可以直接显示的
注:?浏览器分辨文件是基于MIME的，而不会把文件打开查看是否是其他类型，例如用link链接了一个标记为text/plain的文件，就算此文件是css文件，就算其后缀是.css,浏览器依旧不认
text/css?css文件
text/html?HTML文件
image/gif?gif文件
常见的还有image/jpeg、image/png、image/svg
很多浏览器支持icon image/x-icon

let和var的区别
1）let是块作用域，var是函数作用域
2）let没有变量声明提升，var有声明提升
3）存在暂时性死区（TDZ），暂时性死区所指的问题基本都是 先声明后使用的问题
4）在let声明变量所在的作用域，不能重复声明同名变量

20.iterator的作用是什么，怎么布置iterator接口。
1、统一数据结构（数组，对象，map，set，数组包对象，对象包数组）的遍历方式
2、在数据结构上部署iterator接口:所谓的部署接口表现形式为，给对象或数组等集合增加iterator属性，属性的内容是一个根据iterator接口规范自行实现的方法
21cookie和session的区别
session是区别于数据库存在的一种服务器临时存储技术, 它主要存储一些无需持久化的数据, 比如临时的登录状态信息等
cookie是存在于浏览器上的一种浏览器本地存储的方式, 同域名下的cookie不同标签页可以共享, 默认过期时间是浏览器关闭时, 而且在进行http请求时, 会自动带上浏览器全部的cookie发给后台, 后台也可以获取cookie, 设置可以在响应时, 想浏览器中设置cookie。
